< 스레드로부터 정보를 받는 방법들 >

Polling : 스레드한테 끝났냐고 계속 물어보기
Callback : 스레드가 끝났으면 그때 알려주기
	- static으로 구현한 Callback의 문제점은 자신을 부른 인스턴스한테 값을 보내는게 아니고, 클래스 자체한테 값을 보낸다는 점
	- 인자로 this를 보내게 만들면 자신을 부른 인스턴스에게 값을 보내게 바꿀 수 있다.

< 스레드의 확장들 >

Executor : 스레드 공장.
Callable : Return이 있는 스레드 (원래 스레드는 반환 타입이 void임). Run 대신 Call을 쓴다.
Future : 미래에 나올 결과값(Call의 결과)을 대기함.

< 동기화 (Synchronization) >

뜻 : 해당 리소스를 다른 스레드가 쓰지 못하게 독점하는 것
사용 예시 :
	synchronized (System.out) {
		System.out.print(input + ": ");
		System.out.print(ByteToHex(digest));
		System.out.println();
	} // 해당 부분이 실행될 때에는 다른 스레드가 콘솔에 프린트할 수 없다!

> 가능하면 안쓰는게 좋음 Deadlock 걸림<

Deadlock : 교착상태. 필요한 리소스가 다른 상대한테 있어서 진행을 못함
	- 필요한 리소스를 묶어버리거나, 다른 리소스가 있는 경우에만 리소스를 가져올 수 있게 하면 되긴 함


< 우선순위 >

- 스레드의 우선순위를 줄 수 있음
- 근데 별로 효과가 크진 않고, 시스템한테 권고 요청하는 정도임

< Blocking >

- 해당 메소드가 끝날 때 까지 다음 작업으로 넘어가지 않음 (ex. I/O)

< Yield >

- 내 차례를 한 번만 넘김

< Sleep >

- 지정 시간만큼 재우기. Yield 보다 효과적임
- 3초만큼 재우겠다고 해서 3초 뒤에 바로 일어나지 않음. 일어난 뒤에 내 차례가 올때까지 기다려야한다는 점 기억

< Join >

- 다른 스레드가 끝날 때까지 기다리기

< Wait >

- Sleep이랑 비슷하지만, 신호를 줄 때까지 잠
- notify() 를 받으면 일어날 수 있음.
	- 근데 notify() 하면 자고있는 애들 중에 랜덤하게 하나를 깨우는거임
	- notifyAll()은 자고있는 모든 애들을 깨움
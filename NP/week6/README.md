부동 소수점 : 부호, 지수, 가수(소수점 아래부분)로 이뤄짐
	- 식 : 1.(가수) * 2^(지수)
	- 고정 소수점 <=> 부동 소수점

< OutputStreamWriter >
- output stream 이었으면 array로 써야 했던거를 writer를 통해서 쓰면 편하게 문자열로 쓸 수 있음
- OutputStreamWriter(파일명, 인코딩방식)

< FileReader >
- input stream 이었으면 1 byte씩 읽었던 거를 reader를 통해서 읽으면 편하게 문자열로 받을 수 있음
- 얘는 인코딩 하는거 정하지 않아도 됨
- 오프셋, 길이 조정은 보통 reader에서 한다

< 스레드 >
- 프로세스 내에서 동작하는 일의 단위
- 사람(cpu core)이 여러 명이면 일(thread)을 동시에 여러 개 처리할 수 있다
- 어떤 일이 먼저 시작될 지 모름
- 스레드가 필요한 이유 : 서버 입장에서, 읽고 쓰는 일을 여러 클라이언트에게 해줘야 하기 때문에 1 클라이언트 당 1 스레드로 처리할 필요 O.
- 스레드를 만드는 두 방법들 (조금 다름) : 
	- 1. Thread 클래스를 상속(extends) 하는 것 - 무조건 run 함수가 작성되어야 함!!
	!!! 중요 : thread.start()라고 불러야 함 .run() 부르면 스레드로써가 아니라 메소드로써 실행되니까 손해임 동시실행 안됨 !!!
	- 2. Runnable 인터페이스를 구현(implements) 하는 것 - 얘도 무조건 run 함수가 작성되어야 함!!
	!!! 중요 : Runnable을 구현한 클래스(이때까지는 스레드가 아님!) -> 스레드화(기본 스레드 클래스) -> .start() 하기 !!! 
		- 얘를 더 많이 씀. 이유는 class 다중 상속이 안되기 때문임. interface는 다중 구현 가능하니까
- 스레드의 동작을 조절하는 함수들이 있음 (ex. Sleep, yield 등등)
	- Sleep : Thread.sleep(밀리세컨드) 지정한 밀리세컨드만큼 동작을 멈춘다. 근데 정한 만큼 시간이 지나자마자 딱 일어나진 않음
		깨어나 있기는 한데 자기 차례가 와야 일을 하니까 약간 시간 걸릴 수 있음
	- Yield : 내 차례를 "한 번만" 다음 차례한테 넘기기. 다른 스레드들이 할 일이 없으면 바로 다시 내 차례로 옴 (잘 안씀)
	- Wait  : 어떤 다른 스레드가 notify() 해줄 때 까지 기다리기. (Synchronized()랑 같이 써야함)
		- notify()는 한 스레드만 깨우는데, 그 깨우는 애를 지정할 수가 없음!! 모든 애들 깨울때는 notifyAll() 쓰기
	- Join : 특정 스레드가 끝나는걸 기다리기.
	- setPriority : 우선순위 정하기. 1에서부터 10까지 정할 수 있음. 우선순위 높을수록 먼저 처리함 근데 먼저 끝난다는 보장 X
- 프로세스를 여러개 만들 수는 없으니까 스레드를 여러개 만들어서 제공함
- 프로세스는 메모리 영역을 따로 가지지만, 스레드끼리는 메모리 공유가 가능함

< SHA-256 >
- 해시 함수의 일종 (원래 데이터가 뭐였는지 유추 할 수 없음)
- 사이즈에 관계 없이, 256 bit의 값이 나온다
- 예전에는 MD5라는 해시 함수도 썼었음 (128 bit의 값이 나옴)

	
230908 네트워크 프로그래밍 2주차
20211924 이혜림

- 네트워크 프로그래밍은 더이상 특정 전문가만의 전유물이 아니고, 모든 개발자에게 중요한 부분이 됨
- FTP = 파일 전송 프로토콜. 공유 저장소 만들 때 사용했었음
- 자바는 최초로 네트워크 어플리케이션을 위해 바닥부터 설계한 언어 (= 네트워크 친화적)
- 네트워크는 거의 실시간으로 데이터를 주고 받는 컴퓨터나 다른 장치들의 집합
- 노드 : 네트워크 상의 모든 장치. 꼭 컴퓨터만 노드인건 아님
- 호스트 : 노드 중에서 진짜 컴퓨터같은거. 
- 모든 노드는 일련의 바이트로 이루어진 고유한 식별자인 주소를 가지고 있다
- 주소 종류 : IP address(3계층), Ethernet address/Wifi/bluetooth(2, 1계층)

- IP의 버전은 IPv4, IPv6이 있음
- IPv4는 8bit * 4 = 32bit 사용함 대강 40억쯤 되는 고유한 주소를 만들 수 있음
- IPv4는 이미 포화상태인데도 사용할 수 있는 이유
	1. 공유기 : 192.168.xx.xx 이렇게 생긴거 밑에 여러개의 기기가 붙음. 단말기 구분할 때 포트 기반으로 함
	2. DHCP : 동적 호스트 구성 프로토콜. DHCP 서버가 단말기에 IP를 자동으로 부여해줌 (단말기 끄면 다시 뺏어감)

- IPv6는 포화상태인 IPv4 대신에 쓰도록 만듬. 128bit를 사용함
- 16진수 2바이트씩 끊어서 함 (ex. fe80:2919:xxxx:xxxx) 중간에 0 들어오면 스킵함. (ex. fe80::2919.... = fe80:0000:2919...)
- 링크-로컬 IPv6 : 기본으로 할당해줌

- 이더넷 물리적 주소 : 6byte(48bit)로 나타냄. 얘는 바꿀 수 없음 제조될 때부터 정해져있음. 대략 절반 앞부분은 제조사를 나타냄

- 바이트 정렬 방법 : Big endian/Little endian
- MSB : Most Significant Bit (가장 높은 자리수) / LSB : Least Significant Bit (가장 낮은 자리수)
- Big endian : 1234를 1234로 저장함
- Little endian : 1234를 4321로 저장함 
- 데이터 전송할 때는 MSB부터 보냄

- 패킷-스위치  : 데이터를 패킷이라는 덩어리로 쪼개서 하나씩 보내는 방법. 이 때 패킷은 각각 독립적으로 이동함
- 패킷이 라우터로 이동하면, 라우터는 이걸 어디로 다음에 보낼지 정해야 하는데 그걸 라우팅이라고 함
- 라우터만을 위한 알고리즘이 있음 RIP, BGP 등등..
- 패킷-스위치 반대로 서킷-스위치 방법이 있음
- 서킷-스위치 : 송신지랑 수신지가 회선 하나로 쭉 연결됨. 라우터를 중간에 거치는 것 처럼 교환기를 거침 (옛날 집 전화에 씀)
- 아날로그 음성 파형 -> 디지털 음성 할때 이진수로 바꾸는걸 코덱이 함
- 음성을 패킷으로 하면 중간에 유실되거나, 순서가 바뀌거나, 데이터에 비해 헤더가 너무 많다던가(오버헤드) 등의 문제가 있음
- 패킷 유실/순서 바뀜 등을 TCP가 방지해줌

- 프로토콜 : 컴퓨터가 어떻게 통신 할지에 대해 정해둔 규칙. (주소 포맷이나, 데이터가 어떻게 패킷으로 나눠져있나 등등)
- 하이퍼텍스트 = 링크

- 네트워크의 계층 = 보통 TCP/IP 5계층. Application > Transport > Network(Internet) > Data Link > Physical
- 1, 2계층은 통신방식을 결정 (Wifi or Ethernet)
- ppp : 일대일 통신방식. 예전에 쓰던 방법 
- CSMA/CA (Wifi) : 랜덤으로 기다리게 해서 충돌 덜나게 함. 2계층에서 함
- 현 시점 3계층에서 프로토콜은 IP 밖에 없음. 
- IP는 경로를 잘 결정(라우팅)해서 패킷이 이동하도록 함
- 4계층에서 TCP는 패킷마다 번호를 붙여서 보내는 방식이라 유실과 순서 바뀌는 문제를 방지함
- TCP는 패킷의 두 문제를 해결해주지만 UDP는 안해줌 그냥 패킷 보내는게 끝임 재전송도 안함
- TCP 헤더는 20byte나 되는데 UDP 헤더는 8byte밖에 안함
- TCP는 신뢰성있고 UDP는 빠름 (최근에는 UDP로 보내고 5계층(응용)에서 재전송이나 순서 맞추는걸 하도록 하는 추세)
- 3계층에 IP가 있으니까 라우터는 3계층까지 뜯어서 확인해보고 다음으로 보냄
- TCP/UDP는 End to End 프로토콜이라고 함 왜냐면 중간에 라우터는 위에서 말한거처럼 3계층까지만 뜯어보니까 종단 기기만 4계층을 확인하기 때문
- TCP가 붙이는 번호는 1, 2, 3 이게 아니고 바이트만큼 증가함 (ex. 1 [데이터 100바이트] > 101 [데이터 1000바이트] > 1101...)
- TCP를 connection-oriented(연결 지향)라고 함. 처음에 connect 확인하고 데이터를 보냄. 
- connection 확인할 때 3-way handshake를 함 (=> sequence 시작번호를 맞추려고 하는짓)
	1. A->B : sequence 번호를 말함
	2. B->A : 확인 + B가 쓸 sequence 번호를 말함
	3. A->B : 확인
- 포트번호 : IP가 컴퓨터를 구분하는 용도였다면 포트번호는 컴퓨터 내에서 어플리케이션을 구분하는 용도로 쓰임 4계층에서 사용
- 두 개의 프로그램이 같은 포트번호를 쓰면 당연히 안됨.
- 유명한 프로그램의 경우 정해진 포트가 있음 1024번 밑에는 거의 정해져있음 (ex. HTTP는 80번 포트 등등)
- 정해지지 않은 포트는 켜질때 랜덤으로 포트 잡음 

- 이더넷 헤더 : 6byte DST / SRC / 내 다음 프로토콜이 뭔지 (보통 IP)
- TTL : Time To Live. IP 헤더에 있음 라우터 하나 지날때마다 1씩 줄어듬. 0이 되면 얘를 죽임 라우팅 잘못돼서 루프만 도는걸 막기 위함
- IP 헤더만 더해서 확인하는 체크섬이 있음 

※ 과제 : Wireshark로 패킷 하나 잡아서 